<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>WebOS + Lockscreen Neon</title>

<style>
  /* RESET */
  html,body{
    margin:0;
    padding:0;
    height:100%;
    overflow:hidden;
    font-family:"Segoe UI",sans-serif;
    background:black;
    color:white;
  }

  /* ===== LOCKSCREEN LAYER ===== */
  #lockscreen{
    position:fixed;
    inset:0;
    z-index:9999;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    pointer-events:auto;
  }

  #lock-ui{
    text-align:center;
    backdrop-filter:blur(8px);
    background:rgba(255,255,255,0.03);
    padding:45px 50px;
    border-radius:20px;
    box-shadow:0 0 30px rgba(0,255,255,0.2);
    animation:fadeIn 0.7s forwards;
  }

  @keyframes fadeIn{
    from{opacity:0; transform:translateY(20px);}
    to{opacity:1; transform:translateY(0);}
  }

  #clock{
    font-size:90px;
    font-weight:700;
    color:#00eaff;
    text-shadow:0 0 20px #00eaff;
  }

  #date{
    font-size:22px;
    opacity:0.9;
    margin-top:-5px;
  }

  #hint{
    margin-top:20px;
    font-size:14px;
    opacity:0.7;
  }

  /* Fade-out saat unlock */
  .fadeOut{
    animation:fadeExit 0.7s forwards;
  }
  @keyframes fadeExit{
    to{opacity:0; filter:blur(6px);}
  }

  /* Shader canvas */
  #shaderCanvas{
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    display:block;
    z-index:9000;
  }
</style>
</head>

<body>

<!-- =============== LOCKSCREEN =============== -->
<canvas id="shaderCanvas"></canvas>

<div id="lockscreen">
  <div id="lock-ui">
    <div id="clock">00:00</div>
    <div id="date">Loading...</div>
    <div id="hint">Press any key or click to unlock</div>
  </div>
</div>

<script>
/* ================= CLOCK ================= */
const clockEl=document.getElementById("clock");
const dateEl=document.getElementById("date");

function updateClock(){
  const now=new Date();
  const t = now.toLocaleTimeString("id-ID",{hour:"2-digit",minute:"2-digit",hour12:false});
  const d = now.toLocaleDateString("id-ID",{weekday:"long",day:"numeric",month:"long"});

  clockEl.textContent=t;
  dateEl.textContent=d;
}
updateClock();
setInterval(updateClock,1000);

/* =============== UNLOCK ================= */
let unlocked=false;
function unlock(){
  if(unlocked) return;
  unlocked=true;

  document.getElementById("lockscreen").classList.add("fadeOut");
  document.getElementById("shaderCanvas").classList.add("fadeOut");

  setTimeout(()=>{
    document.getElementById("lockscreen").style.display="none";
    document.getElementById("shaderCanvas").style.display="none";
    document.getElementById("desktop").style.display="block";
  },650);
}

window.addEventListener("keydown",unlock);
window.addEventListener("click",unlock);

/* ========== SHADER (100% SAME AS YOUR FILE) ========== */
const vertexShaderSource = `
attribute vec2 position;
void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

const fragmentShaderSource = `
precision highp float;

uniform vec2 r;
uniform float t;

void main() {
  vec2 FC = gl_FragCoord.xy;
  vec2 p = (FC * 2.0 - r) / r.y;
  float a = atan(p.y, p.x);
  float l = length(p);
  vec3 c = vec3(0.0);

  for(float i = 0.0; i < 15.0; i++) {
    float m = sin(a * 10.0 + t * (2.0 + i * 0.5) - l * 20.0) * 0.05;
    c += vec3(2.0, i * 0.1, 1.0) * 0.0008 / abs(l - 0.5 - m + i * 0.015);
  }

  gl_FragColor = vec4(c, 1.0);
}
`;

function createShader(gl,type,source){
  const shader=gl.createShader(type);
  gl.shaderSource(shader,source);
  gl.compileShader(shader);
  return shader;
}

function createProgram(gl,vs,fs){
  const program=gl.createProgram();
  gl.attachShader(program,vs);
  gl.attachShader(program,fs);
  gl.linkProgram(program);
  return program;
}

(function startShader(){
  const canvas=document.getElementById("shaderCanvas");
  const gl=canvas.getContext("webgl");
  if(!gl){ alert("WebGL not supported"); return; }

  const vs=createShader(gl,gl.VERTEX_SHADER,vertexShaderSource);
  const fs=createShader(gl,gl.FRAGMENT_SHADER,fragmentShaderSource);
  const program=createProgram(gl,vs,fs);

  gl.useProgram(program);

  const buffer=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
    -1,-1, 1,-1, -1,1,
    1,-1, 1,1, -1,1
  ]),gl.STATIC_DRAW);

  const posLoc=gl.getAttribLocation(program,"position");
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);

  const rLoc=gl.getUniformLocation(program,"r");
  const tLoc=gl.getUniformLocation(program,"t");

  function resize(){
    canvas.width=innerWidth;
    canvas.height=innerHeight;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  addEventListener("resize",resize);
  resize();

  let start=performance.now();
  function render(){
    const now=performance.now();
    const time=(now-start)*0.001;

    gl.uniform2f(rLoc,canvas.width,canvas.height);
    gl.uniform1f(tLoc,time);

    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(render);
  }
  render();
})();
</script>
