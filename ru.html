<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Permainan Rubik (3x3) - Demo</title>
<style>
  :root{--size:60px}
  body{font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:20px;background:#111;color:#eee}
  h1{font-size:20px;margin-bottom:10px}
  .cube{display:grid;grid-template-columns:repeat(4,calc(var(--size)*3 + 12px));gap:8px;align-items:start}
  .face{display:grid;grid-template-columns:repeat(3, var(--size));gap:4px;padding:6px;background:#222;border-radius:8px}
  .sticker{width:var(--size);height:var(--size);border-radius:6px;box-shadow:inset 0 -2px 0 rgba(0,0,0,0.25);display:flex;align-items:center;justify-content:center;font-weight:700}
  .controls{margin-top:16px;display:flex;gap:8px;flex-wrap:wrap}
  button{background:#1f2937;border:1px solid #374151;padding:8px 10px;border-radius:6px;color:#e6eef8;cursor:pointer}
  button:hover{filter:brightness(1.1)}
  .small{padding:6px 8px;font-size:14px}
  .faces-grid{grid-column:1/4}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .legend .item{display:flex;align-items:center;gap:6px}
  .status{margin-top:12px}
  .hint{color:#9ca3af;font-size:13px}
  @media (max-width:800px){:root{--size:40px}} 
</style>
</head>
<body>
<h1>Permainan Rubik 3x3 â€” Demo</h1>
<p class="hint">Klik tombol gerakan untuk memutar sisi (U,R,F,D,L,B). Ada juga tombol Scramble dan Reset. Ini implementasi sederhana berbasis facelet (3x3 per muka).</p>
<div class="cube">
  <div class="faces-grid">
    <div style="display:grid;grid-template-columns: repeat(3, 1fr);gap:8px;">
      <div></div>
      <div class="face" id="faceU"></div>
      <div></div>
      <div class="face" id="faceL"></div>
      <div class="face" id="faceF"></div>
      <div class="face" id="faceR"></div>
      <div></div>
      <div class="face" id="faceD"></div>
      <div></div>
    </div>
  </div>
  <div style="display:flex;flex-direction:column;gap:8px;">
    <div class="controls" id="moveButtons"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="scrambleBtn">Scramble</button>
      <button id="resetBtn">Reset</button>
      <button id="undoBtn">Undo</button>
      <button id="checkBtn">Cek Selesai</button>
    </div>
    <div class="legend">
      <div class="item"><div style="width:18px;height:18px;background:#fff;border-radius:2px;border:1px solid #222"></div><div>Up (Putih)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#ff8c00;border-radius:2px;border:1px solid #222"></div><div>Right (Oranye)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#00a86b;border-radius:2px;border:1px solid #222"></div><div>Front (Hijau)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#ffd500;border-radius:2px;border:1px solid #222"></div><div>Down (Kuning)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#1e90ff;border-radius:2px;border:1px solid #222"></div><div>Left (Biru)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#d9534f;border-radius:2px;border:1px solid #222"></div><div>Back (Merah)</div></div>
    </div>
    <div class="status" id="status"></div>
  </div>
</div>

<script>
// Facelet indices mapping (0..53)
// Faces in order U,R,F,D,L,B each 9 stickers (row-major)
const FACE_NAMES = ['U','R','F','D','L','B'];
const faceOffsets = {U:0,R:9,F:18,D:27,L:36,B:45};
const COLORS = {U:'#ffffff',R:'#ff8c00',F:'#00a86b',D:'#ffd500',L:'#1e90ff',B:'#d9534f'};

let cube = []; // length 54 storing color keys 'U','R',...
let history = [];

function resetCube(){
  cube = new Array(54);
  for(const f of FACE_NAMES){
    const off = faceOffsets[f];
    for(let i=0;i<9;i++) cube[off+i] = f;
  }
  history = [];
  render();
}

// render faces
function render(){
  for(const f of FACE_NAMES){
    const el = document.getElementById('face'+f);
    el.innerHTML = '';
    const off = faceOffsets[f];
    for(let i=0;i<9;i++){
      const s = document.createElement('div');
      s.className = 'sticker';
      s.style.background = COLORS[cube[off+i]];
      s.dataset.index = off+i;
      el.appendChild(s);
    }
  }
  document.getElementById('status').textContent = 'Moves: '+history.length;
}

// utility rotate a face (clockwise if dir=1, counter if dir=-1)
function rotateFace(face, dir=1){
  const off = faceOffsets[face];
  const old = cube.slice();
  const map = [6,3,0,7,4,1,8,5,2]; // clockwise mapping source indices relative
  for(let i=0;i<9;i++){
    const src = off + map[i];
    cube[off + i] = old[src];
  }
  if(dir===-1){ // if counterclockwise, apply 3 times
    // already applied clockwise once; to get counter, rotate 3 more clockwise (total 3)
  }
}

// cycle 4 groups of 3 indices (groups is array of 4 arrays of 3 indices). Clockwise means group[i+1]=old group[i]
function cycleGroups(groups, clockwise=true){
  const old = cube.slice();
  for(let g=0;g<4;g++){
    const from = groups[g];
    const toIdx = (g+1)%4;
    const to = groups[toIdx];
    if(clockwise){
      for(let i=0;i<3;i++) cube[to[i]] = old[from[i]];
    } else {
      // anticlockwise: from -> previous
      const toPrevIdx = (g+3)%4;
      const toPrev = groups[toPrevIdx];
      for(let i=0;i<3;i++) cube[toPrev[i]] = old[from[i]];
    }
  }
}

// A set of move definitions (best-effort). Each move rotates its face clockwise and cycles adjacent strips.
const MOVES = {
  U: function(){
    // rotate U face
    const old = cube.slice();
    const off=faceOffsets.U;
    const map=[6,3,0,7,4,1,8,5,2];
    for(let i=0;i<9;i++) cube[off+i]=old[off+map[i]];
    // cycle Ftop,Rtop,Btop,Ltop
    cycleGroups([
      [18,19,20], // F top
      [9,10,11],  // R top
      [45,46,47], // B top
      [36,37,38]  // L top
    ], true);
  },
  U_: function(){ for(let i=0;i<3;i++) MOVES.U(); },
  R: function(){
    const old=cube.slice();
    const off=faceOffsets.R; const map=[6,3,0,7,4,1,8,5,2];
    for(let i=0;i<9;i++) cube[off+i]=old[off+map[i]];
    // cycle U right, F right, D right, B left (note B uses reversed order)
    const Uright=[2,5,8];
    const Fright=[20,23,26];
    const Dright=[29,32,35];
    const Bleft=[47,50,53]; // best-effort reversed orientation
    // perform custom cycle preserving direction
    const tmp = Uright.map(i=>old[i]);
    // Uright <- Bleft (reversed)
    cube[2]=old[47]; cube[5]=old[50]; cube[8]=old[53];
    // Fright <- tmp
    cube[20]=tmp[0]; cube[23]=tmp[1]; cube[26]=tmp[2];
    // Dright <- Fright (from old)
    cube[29]=old[20]; cube[32]=old[23]; cube[35]=old[26];
    // Bleft <- Dright (from old) but reversed
    cube[47]=old[29]; cube[50]=old[32]; cube[53]=old[35];
  },
  R_: function(){ for(let i=0;i<3;i++) MOVES.R(); },
  F: function(){
    const old=cube.slice();
    const off=faceOffsets.F; const map=[6,3,0,7,4,1,8,5,2];
    for(let i=0;i<9;i++) cube[off+i]=old[off+map[i]];
    // cycle U bottom, R left col, D top, L right col
    const Ubottom=[6,7,8];
    const Rleft=[9,12,15];
    const Dtop=[27,28,29];
    const Rcol=[9,12,15];
    const Lright=[38,41,44];
    // apply cycle Ubottom->Rleft->Dtop->Lright
    const tmp=Ubottom.map(i=>old[i]);
    cube[9]=tmp[2]; cube[12]=tmp[1]; cube[15]=tmp[0]; // mapping with orientation fixes
    const tmpR=[old[9],old[12],old[15]];
    cube[27]=tmpR[0]; cube[28]=tmpR[1]; cube[29]=tmpR[2];
    const tmpD=[old[27],old[28],old[29]];
    cube[38]=tmpD[2]; cube[41]=tmpD[1]; cube[44]=tmpD[0];
    cube[6]=old[38]; cube[7]=old[41]; cube[8]=old[44];
  },
  F_: function(){ for(let i=0;i<3;i++) MOVES.F(); },
  D: function(){
    const old=cube.slice();
    const off=faceOffsets.D; const map=[6,3,0,7,4,1,8,5,2];
    for(let i=0;i<9;i++) cube[off+i]=old[off+map[i]];
    // cycle F bottom, L bottom, B bottom, R bottom
    cycleGroups([
      [24,25,26], // F bottom
      [42,43,44], // L bottom
      [51,52,53], // B bottom
      [15,16,17]  // R bottom
    ], true);
  },
  D_: function(){ for(let i=0;i<3;i++) MOVES.D(); },
  L: function(){
    const old=cube.slice();
    const off=faceOffsets.L; const map=[6,3,0,7,4,1,8,5,2];
    for(let i=0;i<9;i++) cube[off+i]=old[off+map[i]];
    // cycle U left, B right, D left, F left (with orientation)
    const Uleft=[0,3,6];
    const Bright=[47,50,53];
    const Dleft=[27,30,33];
    const Fleft=[18,21,24];
    const tmp=Uleft.map(i=>old[i]);
    cube[0]=old[18]; cube[3]=old[21]; cube[6]=old[24];
    cube[18]=old[27]; cube[21]=old[30]; cube[24]=old[33];
    cube[27]=old[53]; cube[30]=old[50]; cube[33]=old[47];
    cube[47]=tmp[0]; cube[50]=tmp[1]; cube[53]=tmp[2];
  },
  L_: function(){ for(let i=0;i<3;i++) MOVES.L(); },
  B: function(){
    const old=cube.slice();
    const off=faceOffsets.B; const map=[6,3,0,7,4,1,8,5,2];
    for(let i=0;i<9;i++) cube[off+i]=old[off+map[i]];
    // cycle U top row, L left col, D bottom row, R right col (with orientation flips)
    const Utop=[0,1,2];
    const Lleft=[36,39,42];
    const Dbottom=[33,34,35];
    const Rright=[11,14,17];
    const tmp=Utop.map(i=>old[i]);
    cube[11]=tmp[0]; cube[14]=tmp[1]; cube[17]=tmp[2];
    cube[36]=old[11]; cube[39]=old[14]; cube[42]=old[17];
    cube[33]=old[36]; cube[34]=old[39]; cube[35]=old[42];
    cube[0]=old[33]; cube[1]=old[34]; cube[2]=old[35];
  },
  B_: function(){ for(let i=0;i<3;i++) MOVES.B(); }
};

function applyMove(move){
  history.push(move);
  MOVES[move]();
  render();
}

function undo(){
  if(!history.length) return;
  // naive undo: reset and replay all but last
  const last = history.pop();
  const seq = history.slice();
  resetCube();
  history = [];
  for(const m of seq) { MOVES[m](); history.push(m); }
  render();
}

function scramble(n=20){
  const keys = Object.keys(MOVES).filter(k=>!k.endsWith('_'));
  for(let i=0;i<n;i++){
    const m = keys[Math.floor(Math.random()*keys.length)];
    applyMove(m);
  }
}

function isSolved(){
  for(const f of FACE_NAMES){
    const off=faceOffsets[f];
    for(let i=0;i<9;i++) if(cube[off+i]!==f) return false;
  }
  return true;
}

// build UI buttons
function buildUI(){
  const container=document.getElementById('moveButtons');
  const moves=['U','U_','R','R_','F','F_','D','D_','L','L_','B','B_'];
  for(const m of moves){
    const b=document.createElement('button');
    b.textContent = m.replace('_',"'");
    b.className='small';
    b.onclick = ()=> applyMove(m);
    container.appendChild(b);
  }
  document.getElementById('scrambleBtn').onclick=()=>{scramble(25)};
  document.getElementById('resetBtn').onclick=()=>{resetCube()};
  document.getElementById('undoBtn').onclick=()=>undo();
  document.getElementById('checkBtn').onclick=()=>{
    alert(isSolved()? 'Cube solved!':'Belum selesai');
  }
}

// init
resetCube(); buildUI();

</script>
</body>
</html>
