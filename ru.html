<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Permainan Rubik 3x3 — Simple & Stable</title>
<style>
  :root{--size:56px}
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#0b1220;color:#e6eef8}
  h1{font-size:20px;margin-bottom:6px}
  .container{display:flex;gap:16px;align-items:flex-start}
  .net{display:grid;grid-template-columns:repeat(3,calc(var(--size)*3 + 8px));gap:8px}
  .face{display:grid;grid-template-columns:repeat(3,var(--size));gap:6px;padding:6px;background:#0f1724;border-radius:8px}
  .sticker{width:var(--size);height:var(--size);border-radius:6px;box-shadow:inset 0 -2px 0 rgba(0,0,0,0.25);display:flex;align-items:center;justify-content:center}
  .controls{display:flex;flex-direction:column;gap:10px}
  .buttons{display:flex;flex-wrap:wrap;gap:6px}
  button{background:#122434;border:1px solid #233b46;padding:8px 10px;border-radius:8px;color:#dbeafe;cursor:pointer}
  button.small{padding:6px 8px;font-size:14px}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .status{margin-top:8px;color:#94a3b8}
  @media (max-width:820px){:root{--size:42px}} 
</style>
</head>
<body>
<h1>Permainan Rubik 3x3 — Simple & Stable</h1>
<p class="status">Versi ini memakai model "face arrays" (U,R,F,D,L,B). Semua gerakan dasar (U,R,F,D,L,B) dan inversnya bekerja. Tekan tombol atau gunakan scramble/reset/undo.</p>
<div class="container">
  <div class="net" id="net">
    <div></div>
    <div class="face" id="U"></div>
    <div></div>

    <div class="face" id="L"></div>
    <div class="face" id="F"></div>
    <div class="face" id="R"></div>

    <div></div>
    <div class="face" id="D"></div>
    <div></div>
  </div>

  <div class="controls">
    <div class="buttons" id="moveButtons"></div>
    <div style="display:flex;gap:8px">
      <button id="scrambleBtn">Scramble</button>
      <button id="resetBtn">Reset</button>
      <button id="undoBtn">Undo</button>
      <button id="checkBtn">Cek Selesai</button>
    </div>
    <div class="legend">
      <div class="item"><div style="width:18px;height:18px;background:#ffffff;border-radius:2px;border:1px solid #222"></div><div>U (Putih)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#ff8c00;border-radius:2px;border:1px solid #222"></div><div>R (Oranye)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#00a86b;border-radius:2px;border:1px solid #222"></div><div>F (Hijau)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#ffd500;border-radius:2px;border:1px solid #222"></div><div>D (Kuning)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#1e90ff;border-radius:2px;border:1px solid #222"></div><div>L (Biru)</div></div>
      <div class="item"><div style="width:18px;height:18px;background:#d9534f;border-radius:2px;border:1px solid #222"></div><div>B (Merah)</div></div>
    </div>
    <div class="status" id="status"></div>
  </div>
</div>

<script>
// Faces stored as arrays of 9 elements (row-major): indices 0..8 (top-left -> bottom-right)
const COLORS = {U:'#ffffff',R:'#ff8c00',F:'#00a86b',D:'#ffd500',L:'#1e90ff',B:'#d9534f'};
const FACE_NAMES = ['U','R','F','D','L','B'];
let faces = {}; // faces['U'] = ['U','U',...]
let history = [];

function initFaces(){
  faces = {};
  for(const f of FACE_NAMES){ faces[f] = new Array(9).fill(f); }
  history = [];
}

function render(){
  for(const f of FACE_NAMES){
    const el = document.getElementById(f);
    el.innerHTML = '';
    for(let i=0;i<9;i++){
      const s = document.createElement('div');
      s.className='sticker';
      s.style.background = COLORS[faces[f][i]];
      el.appendChild(s);
    }
  }
  document.getElementById('status').textContent = 'Moves: '+history.length + (isSolved()? ' — Selesai!':'');
}

// rotate face array clockwise
function rotateFaceCW(arr){
  // arr is length 9, return rotated copy
  return [arr[6],arr[3],arr[0],arr[7],arr[4],arr[1],arr[8],arr[5],arr[2]];
}
function rotateFaceCCW(arr){
  return [arr[2],arr[5],arr[8],arr[1],arr[4],arr[7],arr[0],arr[3],arr[6]];
}

// helpers to get/set rows/cols
function getRow(face, r){ // r:0 top,1 mid,2 bottom
  const base = r*3; return [faces[face][base],faces[face][base+1],faces[face][base+2]];
}
function setRow(face, r, vals){ const base=r*3; for(let i=0;i<3;i++) faces[face][base+i]=vals[i]; }
function getCol(face, c){ return [faces[face][c],faces[face][c+3],faces[face][c+6]]; }
function setCol(face, c, vals){ for(let i=0;i<3;i++) faces[face][c+3*i]=vals[i]; }

// Moves (clockwise). Each function applies rotation and updates adjacent face strips.
function moveU(){
  faces.U = rotateFaceCW(faces.U);
  // cycle top rows: F -> R -> B -> L -> F
  const f0 = getRow('F',0), r0 = getRow('R',0), b0 = getRow('B',0), l0 = getRow('L',0);
  setRow('R',0,f0);
  setRow('B',0,r0);
  setRow('L',0,b0);
  setRow('F',0,l0);
}
function moveUi(){ moveU(); moveU(); moveU(); }

function moveD(){
  faces.D = rotateFaceCW(faces.D);
  // cycle bottom rows: F.bottom -> L.bottom -> B.bottom -> R.bottom -> F.bottom (note orientation preserved)
  const f2=getRow('F',2), r2=getRow('R',2), b2=getRow('B',2), l2=getRow('L',2);
  setRow('L',2,f2);
  setRow('B',2,l2);
  setRow('R',2,b2);
  setRow('F',2,r2);
}
function moveDi(){ moveD(); moveD(); moveD(); }

function moveR(){
  faces.R = rotateFaceCW(faces.R);
  // cycle columns: U.right -> F.right -> D.right -> B.left (reversed)
  const uCol = getCol('U',2); // top->bottom
  const fCol = getCol('F',2);
  const dCol = getCol('D',2);
  const bCol = getCol('B',0); // B left column (top->bottom) but orientation flips
  // mapping: U.right -> F.right, F.right -> D.right, D.right -> B.left (reversed), B.left -> U.right (reversed)
  setCol('F',2,uCol);
  setCol('D',2,fCol);
  // for B and U we must reverse where needed
  setCol('B',0,[dCol[2],dCol[1],dCol[0]]);
  setCol('U',2,[bCol[2],bCol[1],bCol[0]]);
}
function moveRi(){ moveR(); moveR(); moveR(); }

function moveL(){
  faces.L = rotateFaceCW(faces.L);
  // cycle columns: U.left -> B.right (reversed) -> D.left -> F.left -> U.left
  const uCol = getCol('U',0);
  const fCol = getCol('F',0);
  const dCol = getCol('D',0);
  const bCol = getCol('B',2);
  setCol('F',0,uCol);
  setCol('D',0,fCol);
  setCol('B',2,[dCol[2],dCol[1],dCol[0]]);
  setCol('U',0,[bCol[2],bCol[1],bCol[0]]);
}
function moveLi(){ moveL(); moveL(); moveL(); }

function moveF(){
  faces.F = rotateFaceCW(faces.F);
  // cycle: U.bottom -> R.left(col 0 top->bottom reversed?) -> D.top -> L.right
  const uBot = getRow('U',2); // left->right
  const rCol = getCol('R',0); // top->bottom
  const dTop = getRow('D',0);
  const lCol = getCol('L',2);
  // mappings with orientation adjustments
  setCol('R',0,[uBot[2],uBot[1],uBot[0]]);
  setRow('D',0,[rCol[0],rCol[1],rCol[2]]);
  setCol('L',2,[dTop[2],dTop[1],dTop[0]]);
  setRow('U',2,[lCol[0],lCol[1],lCol[2]]);
}
function moveFi(){ moveF(); moveF(); moveF(); }

function moveB(){
  faces.B = rotateFaceCW(faces.B);
  // cycle: U.top -> L.left -> D.bottom -> R.right (with orientation adjustments)
  const uTop = getRow('U',0);
  const lCol = getCol('L',0);
  const dBot = getRow('D',2);
  const rCol = getCol('R',2);
  setCol('L',0,[uTop[2],uTop[1],uTop[0]]);
  setRow('D',2,[lCol[2],lCol[1],lCol[0]]);
  setCol('R',2,[dBot[2],dBot[1],dBot[0]]);
  setRow('U',0,[rCol[0],rCol[1],rCol[2]]);
}
function moveBi(){ moveB(); moveB(); moveB(); }

const MOVE_FUNCS = {U:moveU, "U'":moveUi, D:moveD, "D'":moveDi, R:moveR, "R'":moveRi, L:moveL, "L'":moveLi, F:moveF, "F'":moveFi, B:moveB, "B'":moveBi};

function applyMove(m){ history.push(m); MOVE_FUNCS[m](); render(); }

function undo(){ if(!history.length) return; history.pop(); // recompute
  const seq = history.slice(); initFaces(); for(const m of seq) MOVE_FUNCS[m](); history = seq.slice(); render(); }

function scramble(n=20){ const keys=Object.keys(MOVE_FUNCS); for(let i=0;i<n;i++){ const m = keys[Math.floor(Math.random()*keys.length)]; applyMove(m); } }

function isSolved(){ for(const f of FACE_NAMES){ if(faces[f].some(x=>x!==f)) return false; } return true; }

// Build UI
function buildUI(){
  const moves = ['U','U\'','R','R\'','F','F\'','D','D\'','L','L\'','B','B\''];
  const container=document.getElementById('moveButtons');
  moves.forEach(m=>{
    const btn=document.createElement('button'); btn.className='small'; btn.textContent=m; btn.onclick=()=>applyMove(m.replace('\',''));
    container.appendChild(btn);
  });
  document.getElementById('scrambleBtn').onclick=()=>scramble(25);
  document.getElementById('resetBtn').onclick=()=>{initFaces();render();};
  document.getElementById('undoBtn').onclick=()=>undo();
  document.getElementById('checkBtn').onclick=()=>alert(isSolved()? 'Cube solved!':'Belum selesai');
}

// init
initFaces(); buildUI(); render();

</script>
</body>
</html>
