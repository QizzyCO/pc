<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<title>2.5D Adventure — FIXED ROBUST COLLISION</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body { 
    margin:0; 
    background:#0b1220; 
    display:flex; 
    justify-content:center; 
    align-items:center; 
    height:100vh; 
    user-select:none;
  }
  canvas {
    width:1200px;
    height:700px;
    background:#1b3b5e;
    border-radius:12px;
    box-shadow: 0 10px 50px rgba(0,0,0,.6);
  }
</style>
</head>
<body>

<canvas id="game" width="1200" height="700"></canvas>

<script>
/* ======================================================
    2.5D SIDE-SCROLLING ADVENTURE — ROBUST COLLISION FIX
   ====================================================== */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const W = canvas.width;
const H = canvas.height;

/* ============================== WORLD ============================= */

const world = {
  groundY: 560,
  length: 3600,
  platforms: [
    {x:0,    y:560, w:3600, h:40},
    {x:420,  y:460, w:260,  h:40},
    {x:880,  y:400, w:260,  h:40},
    {x:1320, y:340, w:220,  h:40},
    {x:1760, y:420, w:260,  h:40},
    {x:2260, y:360, w:200,  h:40},
    {x:2680, y:450, w:320,  h:40}
  ]
};

/* ============================== OBJECTS ============================ */

let items = [
  {id:"bucket", name:"Ember", x:2300, y:world.groundY-40, taken:false}
];

let npcs = [
  {id:"farmer", name:"Petani", x:3150, y:world.groundY-80, talked:false}
];

/* ============================== PLAYER ============================= */

const player = {
  x: 120,
  y: world.groundY - 100,
  w: 48,
  h: 70,
  vx: 0,
  vy: 0,
  speed: 380,
  jumpPower: -780,
  grounded: false,
  facing: 1,
  inventory: []
};

/* ============================== INPUT ============================== */

let keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup",   e => keys[e.key.toLowerCase()] = false);

/* ============================ COLLISION HELPERS ============================ */

/* Return all platforms horizontally under a given x (footX) */
function platformsUnderX(footX){
  return world.platforms.filter(p => footX >= p.x && footX <= p.x + p.w);
}

/* ============================ PHYSICS (ROBUST) ============================== */

const GRAVITY = 2200;

function updatePhysics(dt){
  // store previous footY for robust crossing detection
  const prevFootY = player.y + player.h;

  // Horizontal move
  let mv = 0;
  if (keys["a"] || keys["arrowleft"])  mv -= 1;
  if (keys["d"] || keys["arrowright"]) mv += 1;

  player.vx = mv * player.speed;
  if (mv) player.facing = mv > 0 ? 1 : -1;

  // Jump
  if ((keys["w"] || keys[" "]) && player.grounded){
    player.vy = player.jumpPower;
    player.grounded = false;
  }

  // Gravity
  player.vy += GRAVITY * dt;

  // Integrate movement
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  // clamp X within world
  if (player.x < 0) player.x = 0;
  if (player.x > world.length - player.w) player.x = world.length - player.w;

  // compute new footY after move
  const footX = player.x + player.w/2;
  const footY = player.y + player.h;

  // check collision with platforms under footX using crossing detection
  const candidates = platformsUnderX(footX);

  // find the platform we landed on (if any) by checking if we crossed its top from above
  let landed = null;
  for (let p of candidates){
    const top = p.y; // top surface (y increasing downwards)
    // if previously above or exactly at top, and now at or below top -> we landed
    if (prevFootY <= top && footY >= top && player.vy >= 0){
      // choose the smallest positive penetration (closest platform we intersected)
      if (!landed || top < landed.y) landed = p;
    }
  }

  if (landed){
    // snap player to platform top
    player.y = landed.y - player.h;
    player.vy = 0;
    player.grounded = true;
    return;
  }

  // if didn't land on any platform, check ground fallback (in case we started above and fell past)
  if (prevFootY <= world.groundY && footY >= world.groundY && player.vy >= 0){
    player.y = world.groundY - player.h;
    player.vy = 0;
    player.grounded = true;
    return;
  }

  // otherwise, still mid-air
  player.grounded = false;
}

/* ============================== CAMERA ============================= */

let camX = 0;

function updateCamera(dt){
  let target = player.x - W*0.4;
  camX += (target - camX) * dt * 8;
  camX = Math.max(0, Math.min(camX, world.length - W));
}

/* ============================ INTERACTION =========================== */

function tryInteract(){
  // PICKUP
  for (let it of items){
    if (it.taken) continue;
    if (Math.abs(it.x - player.x) < 70){
      it.taken = true;
      player.inventory.push(it);
      console.log("Kamu mengambil:", it.name);
      return;
    }
  }

  // NPC TALK
  for (let n of npcs){
    if (Math.abs(n.x - player.x) < 90){
      if (!n.talked){
        n.talked = true;
        console.log(`${n.name}: "Terima kasih telah datang!"`);
      } else {
        console.log(`${n.name}: "Halo lagi!"`);
      }
      return;
    }
  }

  console.log("Tidak ada yang bisa diinteraksi.");
}

/* ============================ RENDERING ============================= */

function drawBackground(){
  let g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, "#76c6ff");
  g.addColorStop(1, "#1d4f8a");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
}

function drawPlatform(p){
  let x = p.x - camX;

  // top
  ctx.fillStyle = "#6fbf4a";
  ctx.fillRect(x, p.y - 12, p.w, 12);

  // front side
  ctx.fillStyle = "#3f7b2e";
  ctx.fillRect(x, p.y, p.w, p.h);

  // shadow edge
  ctx.fillStyle = "rgba(0,0,0,0.15)";
  ctx.fillRect(x, p.y - 12, p.w, 3);
}

function drawPlayer(){
  let x = player.x - camX;

  // shadow
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.beginPath();
  ctx.ellipse(x + player.w/2, player.y + player.h, 24, 10, 0,0,Math.PI*2);
  ctx.fill();

  // body
  ctx.fillStyle = "#ffd85a";
  ctx.fillRect(x, player.y, player.w, player.h);

  // head
  ctx.fillStyle = "#fff0c0";
  ctx.beginPath();
  ctx.arc(x + player.w/2, player.y - 10, 22, 0, Math.PI*2);
  ctx.fill();

  // eye
  ctx.fillStyle = "#222";
  ctx.fillRect(
    x + player.w/2 + player.facing * 10,
    player.y - 14,
    5,5
  );
}

function drawItems(){
  for (let it of items){
    if (it.taken) continue;
    let x = it.x - camX;
    ctx.fillStyle = "#e8a03a";
    ctx.fillRect(x - 20, it.y - 40, 40, 40);
  }
}

function drawNPCs(){
  ctx.font = "14px Arial";
  ctx.fillStyle = "#fff";

  for (let n of npcs){
    let x = n.x - camX;

    ctx.fillStyle = "#7eb3ff";
    ctx.fillRect(x - 20, n.y - 60, 40, 60);

    ctx.fillStyle = "#fff";
    ctx.fillText(n.name, x - 20, n.y - 70);
  }
}

function render(){
  ctx.clearRect(0,0,W,H);
  drawBackground();
  for (let p of world.platforms) drawPlatform(p);
  drawItems();
  drawNPCs();
  drawPlayer();
}

/* ============================== LOOP =============================== */

let last = performance.now();
let consume = {};

function loop(t){
  let dt = (t - last) / 1000;
  last = t;
  if (dt > 0.05) dt = 0.05;

  updatePhysics(dt);
  updateCamera(dt);

  if (keys["e"] && !consume.e){ tryInteract(); consume.e = true; }
  if (!keys["e"]) consume.e = false;

  render();
  requestAnimationFrame(loop);
}

/* Prevent arrow keys from scrolling page */
window.addEventListener("keydown", e=>{
  if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key))
    e.preventDefault();
});

loop();
</script>

</body>
</html>
