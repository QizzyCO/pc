<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Adventure (HTML/Canvas)</title>
<style>
  html,body { height:100%; margin:0; font-family: system-ui, Arial; background:#111; color:#eee; }
  #game-wrap { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }
  #canvas { background: linear-gradient(#7ec0ff,#3a8ed1); border-radius:8px; box-shadow:0 6px 30px rgba(0,0,0,.6); }
  #ui { width:320px; min-width:240px; color:#ddd; }
  .panel { background:rgba(0,0,0,.45); padding:12px; border-radius:8px; margin-bottom:12px; }
  h2 { margin:0 0 8px 0; font-size:16px; color:#fff; }
  .hint { font-size:13px; color:#cfe; }
  .inventory { display:flex; flex-wrap:wrap; gap:8px; }
  .slot { width:56px; height:56px; border:1px solid rgba(255,255,255,.12); display:flex; align-items:center; justify-content:center; border-radius:6px; background:rgba(255,255,255,.02); font-size:12px; }
  button { background:#0ea5a5; border:none; padding:8px 12px; border-radius:6px; color:#012; cursor:pointer; }
  button:active { transform:translateY(1px); }
  #log { max-height:120px; overflow:auto; font-size:13px; color:#dfe; }
  .center { text-align:center; }
  footer { font-size:12px; color:#9aa; margin-top:6px; }
</style>
</head>
<body>
<div id="game-wrap">
  <canvas id="canvas" width="1024" height="768"></canvas>
  <div id="ui">
    <div class="panel">
      <h2>Mini Adventure</h2>
      <div class="hint">Kontrol: WASD atau panah. Tekan <strong>E</strong> untuk interaksi.</div>
      <div style="margin-top:8px;">Status: <span id="status">Sehat</span></div>
      <div style="margin-top:8px;">Posisi: <span id="pos">0,0</span></div>
    </div>

    <div class="panel">
      <h2>Quest</h2>
      <div id="quest">Bicara dengan Petani di utara.</div>
      <div style="margin-top:8px;">
        <button id="btn-reset">Reset Pos</button>
      </div>
    </div>

    <div class="panel">
      <h2>Inventory</h2>
      <div class="inventory" id="inventory"></div>
    </div>

    <div class="panel">
      <h2>Log</h2>
      <div id="log"></div>
    </div>

    <div class="panel center">
      <button id="btn-save">Simpan State (local)</button>
      <button id="btn-load">Muat State</button>
      <div style="margin-top:6px;" class="hint">Game sederhana — cocok untuk dikembangkan lagi.</div>
      <footer>Built by ChatGPT · contoh demo</footer>
    </div>
  </div>
</div>

<script>
/* === Game configuration === */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const TILE = 48;            // ukuran tile (px)
const MAP_W = 32;           // tile lebar
const MAP_H = 20;           // tile tinggi
canvas.width = Math.min(1280, MAP_W * TILE);
canvas.height = Math.min(800, MAP_H * TILE);

/* Simple tile map:
  0 = ground/walk
  1 = wall/rock (blocking)
  2 = water (slow or blocked)
  3 = tall grass (walkable)
*/
let map = new Array(MAP_H).fill(0).map(()=> new Array(MAP_W).fill(0));

// generate simple map: ring of walls + some obstacles
for(let y=0;y<MAP_H;y++){
  for(let x=0;x<MAP_W;x++){
    if (x===0||y===0||x===MAP_W-1||y===MAP_H-1) map[y][x]=1;
    else if (Math.random()<0.02) map[y][x]=1;
    else if (Math.random()<0.03) map[y][x]=2;
    else if (Math.random()<0.06) map[y][x]=3;
  }
}

// carve some paths
for(let i=2;i<MAP_W-2;i++){ map[3][i]=0; map[10][i]=0; }
for(let i=3;i<MAP_H-3;i++){ map[i][8]=0; map[i][15]=0; }

// Player
const player = {
  x: 6, y: 12,    // tile coordinates (sub-tile movement)
  px:0, py:0,     // precise pixel offset (used for smooth movement)
  w: 28, h: 32,
  speed: 160,     // pixels per second
  color: '#ffdd57',
  hp: 100
};

// NPCs and items
let npcs = [
  {id:'farmer', x:8, y:4, name:'Petani', dialog:[
    "Halo! Aku kehilangan emberku.",
    "Kalau kamu menemukan ember, kembalikan padaku ya."
  ], talked:false}
];

let items = [
  {id:'bucket', x:14, y:9, name:'Ember', taken:false}
];

// camera (center on player)
const camera = {x:0,y:0, w:canvas.width, h:canvas.height};

let keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

const ui = {
  status: document.getElementById('status'),
  pos: document.getElementById('pos'),
  quest: document.getElementById('quest'),
  inventory: document.getElementById('inventory'),
  log: document.getElementById('log'),
  btnReset: document.getElementById('btn-reset'),
  btnSave: document.getElementById('btn-save'),
  btnLoad: document.getElementById('btn-load')
};

ui.btnReset.addEventListener('click', ()=>{ player.x=6; player.y=12; log('Posisi di-reset.'); });
ui.btnSave.addEventListener('click', saveState);
ui.btnLoad.addEventListener('click', loadState);

function log(text){
  const node = document.createElement('div');
  node.textContent = text;
  ui.log.prepend(node);
}

/* ===== Collision helpers ===== */
function isBlockingTile(tx,ty){
  if (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return true;
  const t = map[ty][tx];
  return (t===1 || t===2); // water also blocking for simplicity
}

/* ===== Game loop ===== */
let last = performance.now();
let inventory = [];

function update(dt){
  // movement
  let dx = 0, dy = 0;
  if (keys['w'] || keys['arrowup']) dy -= 1;
  if (keys['s'] || keys['arrowdown']) dy += 1;
  if (keys['a'] || keys['arrowleft']) dx -= 1;
  if (keys['d'] || keys['arrowright']) dx += 1;

  // normalize diagonal
  if (dx !== 0 && dy !== 0){ const inv = 1/Math.sqrt(2); dx*=inv; dy*=inv; }

  const movePx = player.speed * dt;
  let newPx = player.x * TILE + player.px + dx * movePx;
  let newPy = player.y * TILE + player.py + dy * movePx;

  // compute tile coords we'll collide with
  const newTileX = Math.floor((newPx + player.w/2) / TILE);
  const newTileY = Math.floor((newPy + player.h/2) / TILE);

  if (!isBlockingTile(newTileX, newTileY)){
    // update pixel offsets, and update player's tile when crossing tile boundary
    player.px = newPx - player.x * TILE;
    player.py = newPy - player.y * TILE;
    // tile alignment
    if (player.px > TILE/2) { player.x++; player.px -= TILE; }
    if (player.px < -TILE/2) { player.x--; player.px += TILE; }
    if (player.py > TILE/2) { player.y++; player.py -= TILE; }
    if (player.py < -TILE/2) { player.y--; player.py += TILE; }
  } else {
    // simple slide: try axis separately
    const tryXTile = Math.floor((newPx + player.w/2) / TILE);
    const tryYTile = Math.floor((player.y * TILE + player.py + player.h/2) / TILE);
    if (!isBlockingTile(tryXTile, tryYTile)) {
      player.px = newPx - player.x * TILE;
    } else {
      const tryY2 = Math.floor((player.x * TILE + player.px + player.h/2) / TILE);
      const tryX2 = Math.floor((player.y * TILE + player.py + player.h/2) / TILE);
      // no change if blocked
    }
  }

  // update HUD
  ui.status.textContent = `HP ${player.hp}`;
  ui.pos.textContent = `${player.x}, ${player.y}`;

  // interaction key
  if (keys['e']){
    keys['e'] = false; // consume
    tryInteract();
  }

  // check item pickup (if standing on same tile)
  for (let it of items){
    if (!it.taken && it.x === player.x && it.y === player.y){
      it.taken = true;
      inventory.push(it);
      updateInventoryUI();
      log(`Kamu mengambil: ${it.name}`);
      // update quest if item is ember
      if (it.id === 'bucket') ui.quest.textContent = "Kembalikan ember ke Petani.";
    }
  }

  // check NPC proximity for auto hint
  for (let n of npcs){
    const dist = Math.abs(n.x - player.x) + Math.abs(n.y - player.y);
    if (dist <= 1 && !n.talked) {
      // hint
      // (no auto speak; press E to interact)
    }
  }

  // simple quest completion
  const farmer = npcs.find(n=>n.id==='farmer');
  if (farmer && farmer.x===player.x && farmer.y===player.y){
    // if has bucket and hasn't completed
    if (inventory.find(i=>i.id==='bucket') && !farmer.talked){
      farmer.talked = true;
      // remove bucket from inventory
      inventory = inventory.filter(i=>i.id!=='bucket');
      updateInventoryUI();
      ui.quest.textContent = "Quest selesai: Ember dikembalikan.";
      log("Kamu memberikan ember ke Petani. Quest selesai!");
    }
  }
}

function tryInteract(){
  // check adjacent NPCs
  for (let n of npcs){
    const dist = Math.abs(n.x - player.x) + Math.abs(n.y - player.y);
    if (dist <= 1){
      // show dialog (simple alert-style)
      showDialog(n);
      return;
    }
  }
  log("Tidak ada yang bisa diinteraksi.");
}

function showDialog(npc){
  // cycle through dialog and mark talked when finished
  const dlg = npc.dialog.shift();
  if (dlg){
    log(`${npc.name}: "${dlg}"`);
  } else {
    log(`${npc.name}: "Terima kasih."`);
    npc.talked = true;
  }
}

/* ===== Drawing ===== */
function draw(){
  // camera center
  camera.x = player.x * TILE + player.px - canvas.width/2 + player.w/2;
  camera.y = player.y * TILE + player.py - canvas.height/2 + player.h/2;

  // clamp camera
  camera.x = Math.max(0, Math.min(camera.x, MAP_W*TILE - canvas.width));
  camera.y = Math.max(0, Math.min(camera.y, MAP_H*TILE - canvas.height));

  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw tiles
  for (let y=0;y<MAP_H;y++){
    for (let x=0;x<MAP_W;x++){
      const sx = x*TILE - camera.x;
      const sy = y*TILE - camera.y;
      const t = map[y][x];
      if (t===0){
        // ground
        drawRect(sx,sy,TILE,TILE, '#88c070');
      } else if (t===1){
        // wall
        drawRect(sx,sy,TILE,TILE, '#5a4f3a');
        // rock shading
        ctx.fillStyle = 'rgba(0,0,0,.18)';
        ctx.fillRect(sx,sy+TILE*0.66,TILE,TILE*0.34);
      } else if (t===2){
        drawRect(sx,sy,TILE,TILE, '#2b6ea3'); // water
      } else if (t===3){
        drawRect(sx,sy,TILE,TILE, '#6aa04a'); // tall grass (slightly different)
        ctx.fillStyle = 'rgba(0,0,0,.06)';
        ctx.fillRect(sx,sy,TILE,TILE);
      }
      // tile grid (subtle)
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.strokeRect(sx,sy,TILE,TILE);
    }
  }

  // draw items
  for (let it of items){
    if (it.taken) continue;
    const sx = it.x*TILE - camera.x + TILE/2 - 10;
    const sy = it.y*TILE - camera.y + TILE/2 - 10;
    // simple icon
    ctx.fillStyle = '#e8a63a';
    roundRect(ctx, sx, sy, 20,20,4, true, false);
    ctx.fillStyle = '#222';
    ctx.font = '11px sans-serif';
    ctx.fillText('I', sx+6, sy+14);
  }

  // draw NPCs
  for (let n of npcs){
    const sx = n.x*TILE - camera.x + TILE/2;
    const sy = n.y*TILE - camera.y + TILE/2;
    // body
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(sx, sy-6, 10, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#6b3';
    ctx.fillRect(sx-8, sy+2, 16, 12);
    // name
    ctx.fillStyle = '#fff';
    ctx.font = '12px sans-serif';
    ctx.fillText(n.name, sx-14, sy-18);
  }

  // draw player (simple)
  const px = player.x*TILE + player.px - camera.x;
  const py = player.y*TILE + player.py - camera.y;
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(px + player.w/2, py + player.h - 6, player.w/2, 6, 0, 0, Math.PI*2);
  ctx.fill();
  // body
  ctx.fillStyle = player.color;
  roundRect(ctx, px + (TILE-player.w)/2, py + (TILE-player.h)/2, player.w, player.h, 6, true, false);
  // face
  ctx.fillStyle = '#222';
  ctx.fillRect(px + (TILE-player.w)/2 + 8, py + (TILE-player.h)/2 + 8, 6,6);
  ctx.fillRect(px + (TILE-player.w)/2 + player.w - 16, py + (TILE-player.h)/2 + 8, 6,6);

  // draw HUD mini compass / minimap (small)
  drawMiniMap();
}

/* ===== Helpers ===== */
function drawRect(x,y,w,h,color){
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x)+.5, Math.round(y)+.5, Math.round(w), Math.round(h));
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof stroke === 'undefined') stroke = true;
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

function drawMiniMap(){
  const mapW = 160, mapH = 100;
  const mx = canvas.width - mapW - 12, my = 12;
  // background
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  roundRect(ctx, mx-6, my-6, mapW+12, mapH+12, 8, true, false);
  // tiles small
  const scaleX = mapW / MAP_W, scaleY = mapH / MAP_H;
  for (let y=0;y<MAP_H;y++){
    for (let x=0;x<MAP_W;x++){
      const t = map[y][x];
      let color = '#6fa96b';
      if (t===1) color = '#3b2f24';
      if (t===2) color = '#225b86';
      ctx.fillStyle = color;
      ctx.fillRect(mx + x*scaleX, my + y*scaleY, Math.ceil(scaleX), Math.ceil(scaleY));
    }
  }
  // player dot
  ctx.fillStyle = '#ffeb3b';
  ctx.fillRect(mx + player.x*scaleX - 2, my + player.y*scaleY - 2, 4, 4);
  // NPCs
  ctx.fillStyle = '#fff';
  for (let n of npcs) ctx.fillRect(mx + n.x*scaleX - 2, my + n.y*scaleY - 2, 4,4);
}

/* ===== Inventory UI ===== */
function updateInventoryUI(){
  ui.inventory.innerHTML = '';
  if (inventory.length === 0) {
    ui.inventory.innerHTML = '<div style="color:#888">Kosong</div>';
    return;
  }
  for (let it of inventory){
    const slot = document.createElement('div');
    slot.className = 'slot';
    slot.textContent = it.name;
    ui.inventory.appendChild(slot);
  }
}

/* ===== Save / Load state (localStorage) ===== */
function saveState(){
  const state = {
    player: {x:player.x,y:player.y,px:player.px,py:player.py,hp:player.hp},
    inventory,
    items,
    npcs,
    quest: ui.quest.textContent
  };
  localStorage.setItem('miniAdventureSave', JSON.stringify(state));
  log('State disimpan ke localStorage.');
}

function loadState(){
  const raw = localStorage.getItem('miniAdventureSave');
  if (!raw){ log('Tidak ada save ditemukan.'); return; }
  try {
    const s = JSON.parse(raw);
    player.x = s.player.x; player.y = s.player.y; player.px = s.player.px; player.py = s.player.py; player.hp = s.player.hp;
    inventory = s.inventory || [];
    for (let it of items){ // synchronize items
      const found = inventory.find(i=>i.id===it.id);
      it.taken = !!found;
    }
    if (s.npcs) npcs = s.npcs;
    ui.quest.textContent = s.quest || ui.quest.textContent;
    updateInventoryUI();
    log('State dimuat.');
  } catch(e){
    log('Gagal memuat save: '+e);
  }
}

/* ===== Main loop ===== */
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000);
  update(dt);
  draw();
  last = now;
  requestAnimationFrame(loop);
}

/* Start */
updateInventoryUI();
log('Selamat datang — mulai menjelajah dunia kecil ini!');
requestAnimationFrame(loop);

/* Keyboard: prevent scroll when arrow keys pressed */
window.addEventListener("keydown", function(e) {
  if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].indexOf(e.key) > -1) {
    e.preventDefault();
  }
}, false);

</script>
</body>
</html>
