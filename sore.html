<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AICM-style multiple rolling coins — Diagnostic</title>

<!-- three.js -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<!-- orbit controls - disabled by default, handy for debug -->
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<style>
  :root{ --bg1:#f7f3ff; --bg2:#ebe8f6; --bg3:#e7e5f0; }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,var(--bg1),var(--bg2) 40%,var(--bg3) 100%); font-family:Poppins,system-ui,Arial; overflow:hidden;}
  canvas{display:block; width:100vw; height:100vh;}

  /* HERO TEXT */
  .hero{position:absolute; left:6%; top:50%; transform:translateY(-50%); z-index:6; color:#0f1724; pointer-events:none; max-width:540px;}
  .hero h1{margin:0; font-size:clamp(28px,4.8vw,56px); line-height:1.05; font-weight:700}
  .hero p{margin:12px 0 20px; opacity:0.75}
  .hero .btn{pointer-events:auto; display:inline-block; background:#071030; color:#fff; padding:12px 26px; border-radius:36px; text-decoration:none; font-weight:600}

  .noise{position:absolute; inset:0; background-image:url('https://i.ibb.co/2dYwMDr/noise.png'); opacity:0.16; mix-blend-mode:overlay; z-index:5; pointer-events:none}
  .vignette{position:absolute; right:6%; bottom:6%; width:480px; height:480px; border-radius:50%; background:radial-gradient(circle at 30% 30%, rgba(255,255,255,0.85), rgba(255,255,255,0.08) 35%, transparent 60%); filter:blur(30px); z-index:3; pointer-events:none}

  .hint {position:absolute; right:18px; bottom:12px; z-index:7; font-size:13px; color:rgba(0,0,0,0.45);}

  /* Diagnostic overlay */
  .diag {
    position: absolute; left: 50%; top: 12px; transform: translateX(-50%); z-index: 20;
    background: rgba(0,0,0,0.6); color: #fff; padding: 8px 14px; border-radius: 12px; font-size:13px;
    display: inline-flex; gap:10px; align-items:center;
  }
  .diag.ok { background: rgba(18,130,75,0.95); }
  .diag.err { background: rgba(180,40,30,0.95); }

  /* fallback CSS coin (only visible if WebGL fails) */
  .fallback {
    position: absolute; right: 10%; bottom: 18%; z-index: 15; pointer-events:none;
    width: 140px; height: 140px; display: none; align-items:center; justify-content:center;
  }
  .fcoin {
    width:100px; height:100px; border-radius:50%; background: radial-gradient(circle at 30% 25%, #fff9e6, #ffd45e 20%, #c48f10 100%);
    box-shadow: 0 10px 30px rgba(0,0,0,0.12); display:block; transform-origin:50% 50%;
    animation: rollInCSS 2.6s cubic-bezier(.25,.8,.25,1) forwards;
  }
  @keyframes rollInCSS {
    0% { transform: translateX(300px) rotate(0deg); opacity:0; }
    10% { opacity:1; }
    75% { transform: translateX(0) rotate(-720deg); }
    90% { transform: translateX(-10px) rotate(-760deg) scale(1.05); }
    100% { transform: translateX(0) rotate(-720deg) scale(1); }
  }
</style>
</head>
<body>
  <div class="hero">
    <h1>The Smarter,<br> AI-Powered<br> Decentralized<br> Marketplace</h1>
    <p>Harness the power of decentralized AI marketplace with AICM.</p>
    <a class="btn" href="#">Search with AICM</a>
  </div>

  <div id="diag" class="diag">Checking WebGL…</div>

  <canvas id="c"></canvas>
  <div class="noise"></div>
  <div class="vignette"></div>
  <div class="hint">Klik layar untuk replay animation</div>

  <!-- Fallback coin -->
  <div class="fallback" id="fallback">
    <div class="fcoin"></div>
  </div>

<script>
/*
  Diagnostic wrapper -> tries to initialize WebGL/Three renderer.
  If fails, shows readable error message and CSS fallback coin.
  If succeeds, runs your Three.js scene (unchanged).
*/

const diag = document.getElementById('diag');
const fallback = document.getElementById('fallback');

function showDiag(text, ok = true) {
  diag.textContent = text;
  diag.classList.toggle('ok', ok);
  diag.classList.toggle('err', !ok);
}

/* Try to create temporary WebGL context to detect support */
function canCreateWebGL(glVersion='webgl2') {
  const canvas = document.createElement('canvas');
  try {
    const ctx = canvas.getContext(glVersion, { antialias: true, alpha: true });
    if (ctx) {
      // some environments provide WebGL2 but disabled later; still indicates capability
      return true;
    }
  } catch(e) {}
  // try webgl fallback
  try {
    const ctx = canvas.getContext('webgl', { antialias: true, alpha: true }) || canvas.getContext('experimental-webgl');
    return !!ctx;
  } catch(e){}
  return false;
}

/* If no WebGL, show fallback and instructions */
if (!canCreateWebGL('webgl2') && !canCreateWebGL('webgl')) {
  showDiag('WebGL tidak tersedia pada browser ini — menampilkan fallback CSS. (Aktifkan hardware acceleration & reload)', false);
  fallback.style.display = 'flex';
  console.error('WebGL not available. Try enabling Hardware Acceleration in Chrome > Settings > System.');
} else {
  // attempt to initialize renderer and catch exceptions
  try {
    // original renderer init (kept minimal)
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    // If renderer.domElement is null or context can't be created, this may throw in some envs.
    if (!renderer || !renderer.getContext()) {
      throw new Error('Renderer or WebGL context creation failed.');
    }

    showDiag('WebGL ready — rendering scene', true);

    // === BEGIN original scene code ===
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    // renderer.outputColorSpace may not exist on older three builds; guard it
    if ('outputColorSpace' in renderer) {
      try { renderer.outputColorSpace = THREE.SRGBColorSpace; } catch(e) {}
    }

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0xf4f2fb, 0.00055);

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.set(-100, 30, 260);

    const hemi = new THREE.HemisphereLight(0xffffff, 0xaaaaaa, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.15);
    dir.position.set(120, 220, 100);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024,1024);
    dir.shadow.camera.left = -300; dir.shadow.camera.right=300; dir.shadow.camera.top=300; dir.shadow.camera.bottom=-300;
    scene.add(dir);
    const fill = new THREE.PointLight(0xfff7e8, 0.55, 900);
    fill.position.set(-220, 80, 160);
    scene.add(fill);
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.ShadowMaterial({opacity:0.12}));
    ground.rotation.x = -Math.PI/2; ground.position.y = -62; ground.receiveShadow = true;
    scene.add(ground);

    /* ---------- glass ring (torus) ---------- */
    const ringGeo = new THREE.TorusGeometry(360, 85, 64, 160);
    const ringMat = new THREE.MeshPhysicalMaterial({
      color:0xffffff, metalness:0, roughness:0.18, transmission:0.9, thickness:6, opacity:0.9, transparent:true, clearcoat:0.8, clearcoatRoughness:0.05
    });
    const glassRing = new THREE.Mesh(ringGeo, ringMat);
    glassRing.position.set(180, 38, -40);
    glassRing.rotation.set(THREE.Math.degToRad(12), THREE.Math.degToRad(-18), 0);
    scene.add(glassRing);

    const loader = new THREE.TextureLoader();
    // guard texture loading errors
    loader.crossOrigin = ''; // let browser attempt crossOrigin
    const soft = loader.load('https://i.ibb.co/9ntk7Xb/softcircle.png',
      ()=>{}, // onLoad
      undefined,
      (err)=>{ console.warn('Texture softcircle failed to load', err); }
    );
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:soft, color:0xffffff, transparent:true, opacity:0.28}));
    sprite.scale.set(620,620,1);
    sprite.position.copy(glassRing.position).add(new THREE.Vector3(-48,-44,0));
    scene.add(sprite);

    /* coin utils (same as your code) */
    function createCoinFaceTexture(text, size=1024){
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      const g = ctx.createRadialGradient(size*0.3, size*0.24, size*0.05, size/2, size/2, size/1.2);
      g.addColorStop(0,'#fff9e6'); g.addColorStop(0.2,'#ffe77a'); g.addColorStop(0.6,'#d99e1a'); g.addColorStop(1,'#c48f10');
      ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
      ctx.globalAlpha = 0.06;
      for(let i=0;i<1200;i++){ ctx.fillStyle = i%2==0? 'rgba(255,255,255,0.02)': 'rgba(0,0,0,0.02)'; const x=Math.random()*size,y=Math.random()*size,w=Math.random()*2; ctx.fillRect(x,y,w,0.5);}
      ctx.globalAlpha = 1;
      ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=size*0.03; ctx.beginPath(); ctx.arc(size/2,size/2,size*0.36,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle = '#fff9e6'; ctx.font = `${Math.floor(size*0.12)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, size/2, size/2);
      const tex = new THREE.CanvasTexture(c); tex.encoding = THREE.sRGBEncoding; tex.needsUpdate=true; return tex;
    }

    const coinRadius = 40, coinThickness = 6, RIM = 8;
    function makeCoin(label='AICM'){
      const group = new THREE.Group();
      const rimGeo = new THREE.CylinderGeometry(coinRadius+RIM, coinRadius+RIM, coinThickness+2, 64);
      const rimMat = new THREE.MeshStandardMaterial({color:0xbd8a10, metalness:1.0, roughness:0.26});
      const rim = new THREE.Mesh(rimGeo, rimMat); rim.rotation.x = Math.PI/2; rim.castShadow=true; group.add(rim);
      const bodyGeo = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 64);
      const bodyMat = new THREE.MeshPhysicalMaterial({color:0xe3b335, metalness:1.0, roughness:0.18, clearcoat:0.6, clearcoatRoughness:0.04});
      const body = new THREE.Mesh(bodyGeo, bodyMat); body.rotation.x = Math.PI/2; body.castShadow=true; group.add(body);
      const faceTex = createCoinFaceTexture(label,1024);
      const faceMat = new THREE.MeshStandardMaterial({map:faceTex, metalness:0.7, roughness:0.22});
      const faceGeom = new THREE.CircleGeometry(coinRadius-2, 64);
      const faceA = new THREE.Mesh(faceGeom, faceMat); faceA.rotation.x = Math.PI/2; faceA.position.z = coinThickness/2+0.6; faceA.castShadow=true; group.add(faceA);
      const faceB = new THREE.Mesh(faceGeom, faceMat.clone()); faceB.rotation.x = -Math.PI/2; faceB.position.z = -coinThickness/2-0.6; group.add(faceB);
      return group;
    }

    const coins = []; const coinCount = 3;
    for(let i=0;i<coinCount;i++){
      const g = makeCoin(i===0? 'AICM' : i===1? 'A' : '1');
      g.scale.set(1.8,1.8,1.8);
      g.position.set(420 + i*60, 0, 0);
      scene.add(g);
      coins.push({group:g, delay:i*280});
    }

    const START_X = 420, TARGET_X = -120, MOVE_DURATION = 2800; let startT = null;
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    function render(ts){
      if(!startT) startT = ts;
      const elapsed = ts - startT;
      coins.forEach((c,idx) => {
        const localT = Math.max(0, elapsed - c.delay);
        const p = Math.min(localT / MOVE_DURATION, 1);
        const eased = easeOutCubic(p);
        const x = THREE.MathUtils.lerp(START_X + idx*30, TARGET_X + idx*18, eased);
        c.group.position.x = x;
        const traveled = (START_X + idx*30) - x;
        const angle = traveled / (coinRadius * 1.0);
        c.group.rotation.y = -angle;
        if(p > 0.82 && p < 1){
          const t2 = (p - 0.82) / 0.18;
          c.group.position.y = Math.sin(t2 * Math.PI * 2) * (1 - t2) * 7;
        } else if(p >= 1){
          c.group.position.y = 0;
          c.group.rotation.x = Math.sin(ts * 0.0015 + idx) * 0.03;
        }
      });
      camera.position.x += (-60 - camera.position.x) * 0.02;
      camera.lookAt(0, 10, 0);
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

    /* click to replay */
    window.addEventListener('click', () => {
      startT = null;
      coins.forEach((c, idx) => { c.group.position.set(START_X + idx*30, 0, 0); c.group.rotation.set(0,0,0); });
    });

    // finished init
    showDiag('WebGL ready — rendering scene', true);

    // === END original scene code ===

  } catch (err) {
    console.error('Three.js init error:', err);
    showDiag('Error saat inisialisasi WebGL — tampilkan fallback.', false);
    fallback.style.display = 'flex';
  }
}
</script>
</body>
</html>
