<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AICM-style multiple rolling coins</title>

<!-- three.js -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<!-- orbit controls - disabled by default, handy for debug -->
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<style>
  :root{
    --bg1:#f7f3ff; --bg2:#ebe8f6; --bg3:#e7e5f0;
  }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,var(--bg1),var(--bg2) 40%,var(--bg3) 100%); font-family:Poppins,system-ui,Arial; overflow:hidden;}
  canvas{display:block; width:100vw; height:100vh;}

  /* HERO TEXT */
  .hero{
    position:absolute; left:6%; top:50%; transform:translateY(-50%); z-index:6; color:#0f1724; pointer-events:none; max-width:540px;
  }
  .hero h1{margin:0; font-size:clamp(28px,4.8vw,56px); line-height:1.05; font-weight:700}
  .hero p{margin:12px 0 20px; opacity:0.75}
  .hero .btn{pointer-events:auto; display:inline-block; background:#071030; color:#fff; padding:12px 26px; border-radius:36px; text-decoration:none; font-weight:600}

  .noise{position:absolute; inset:0; background-image:url('https://i.ibb.co/2dYwMDr/noise.png'); opacity:0.16; mix-blend-mode:overlay; z-index:5; pointer-events:none}
  .vignette{position:absolute; right:6%; bottom:6%; width:480px; height:480px; border-radius:50%; background:radial-gradient(circle at 30% 30%, rgba(255,255,255,0.85), rgba(255,255,255,0.08) 35%, transparent 60%); filter:blur(30px); z-index:3; pointer-events:none}

  /* small instruction */
  .hint {position:absolute; right:18px; bottom:12px; z-index:7; font-size:13px; color:rgba(0,0,0,0.45);}
</style>
</head>
<body>
  <div class="hero">
    <h1>The Smarter,<br> AI-Powered<br> Decentralized<br> Marketplace</h1>
    <p>Harness the power of decentralized AI marketplace with AICM.</p>
    <a class="btn" href="#">Search with AICM</a>
  </div>

  <canvas id="c"></canvas>
  <div class="noise"></div>
  <div class="vignette"></div>
  <div class="hint">Klik layar untuk replay animation</div>

<script>
/* --------- Setup renderer, scene, camera --------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0xf4f2fb, 0.00055);

const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 5000);
camera.position.set(-100, 30, 260);

/* lights */
const hemi = new THREE.HemisphereLight(0xffffff, 0xaaaaaa, 0.6);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 1.15);
dir.position.set(120, 220, 100);
dir.castShadow = true;
dir.shadow.mapSize.set(1024,1024);
dir.shadow.camera.left = -300; dir.shadow.camera.right=300; dir.shadow.camera.top=300; dir.shadow.camera.bottom=-300;
scene.add(dir);

const fill = new THREE.PointLight(0xfff7e8, 0.55, 900);
fill.position.set(-220, 80, 160);
scene.add(fill);

/* ground for shadow catcher */
const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.ShadowMaterial({opacity:0.12}));
ground.rotation.x = -Math.PI/2; ground.position.y = -62; ground.receiveShadow = true;
scene.add(ground);

/* ---------- glass ring (torus) ---------- */
const ringGeo = new THREE.TorusGeometry(360, 85, 64, 160);
const ringMat = new THREE.MeshPhysicalMaterial({
  color:0xffffff, metalness:0, roughness:0.18, transmission:0.9, thickness:6, opacity:0.9, transparent:true, clearcoat:0.8, clearcoatRoughness:0.05
});
const glassRing = new THREE.Mesh(ringGeo, ringMat);
glassRing.position.set(180, 38, -40);
glassRing.rotation.set(THREE.Math.degToRad(12), THREE.Math.degToRad(-18), 0);
glassRing.castShadow = false; glassRing.receiveShadow = false;
scene.add(glassRing);

/* radial sprite glow near ring */
const loader = new THREE.TextureLoader();
const soft = loader.load('https://i.ibb.co/9ntk7Xb/softcircle.png');
const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:soft, color:0xffffff, transparent:true, opacity:0.28}));
sprite.scale.set(620,620,1); sprite.position.copy(glassRing.position).add(new THREE.Vector3(-48,-44,0));
scene.add(sprite);

/* ---------- coin creation (programmatic) ---------- */
function createCoinFaceTexture(text, size=1024){
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  // radial gold
  const g = ctx.createRadialGradient(size*0.3, size*0.24, size*0.05, size/2, size/2, size/1.2);
  g.addColorStop(0,'#fff9e6'); g.addColorStop(0.2,'#ffe77a'); g.addColorStop(0.6,'#d99e1a'); g.addColorStop(1,'#c48f10');
  ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
  // scratches
  ctx.globalAlpha = 0.06;
  for(let i=0;i<2200;i++){ ctx.fillStyle = i%2==0? 'rgba(255,255,255,0.02)': 'rgba(0,0,0,0.02)'; const x=Math.random()*size,y=Math.random()*size,w=Math.random()*2; ctx.fillRect(x,y,w,0.5);}
  ctx.globalAlpha = 1;
  // inner ring
  ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=size*0.03;
  ctx.beginPath(); ctx.arc(size/2,size/2,size*0.36,0,Math.PI*2); ctx.stroke();
  // emblem text
  ctx.fillStyle = '#fff9e6'; ctx.font = `${Math.floor(size*0.12)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text, size/2, size/2);
  const tex = new THREE.CanvasTexture(c); tex.encoding = THREE.sRGBEncoding; tex.needsUpdate=true; return tex;
}

const coinRadius = 40;
const coinThickness = 6;
const RIM = 8;

function makeCoin(label='AICM'){
  const group = new THREE.Group();
  // rim
  const rimGeo = new THREE.CylinderGeometry(coinRadius+RIM, coinRadius+RIM, coinThickness+2, 64);
  const rimMat = new THREE.MeshStandardMaterial({color:0xbd8a10, metalness:1.0, roughness:0.26});
  const rim = new THREE.Mesh(rimGeo, rimMat); rim.rotation.x = Math.PI/2; rim.castShadow=true; rim.receiveShadow=true; group.add(rim);
  // body
  const bodyGeo = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 64);
  const bodyMat = new THREE.MeshPhysicalMaterial({color:0xe3b335, metalness:1.0, roughness:0.18, clearcoat:0.6, clearcoatRoughness:0.04});
  const body = new THREE.Mesh(bodyGeo, bodyMat); body.rotation.x = Math.PI/2; body.castShadow=true; group.add(body);
  // faces
  const faceTex = createCoinFaceTexture(label,1024);
  const faceMat = new THREE.MeshStandardMaterial({map:faceTex, metalness:0.7, roughness:0.22});
  const faceGeom = new THREE.CircleGeometry(coinRadius-2, 64);
  const faceA = new THREE.Mesh(faceGeom, faceMat); faceA.rotation.x = Math.PI/2; faceA.position.z = coinThickness/2+0.6; faceA.castShadow=true; group.add(faceA);
  const faceB = new THREE.Mesh(faceGeom, faceMat.clone()); faceB.rotation.x = -Math.PI/2; faceB.position.z = -coinThickness/2-0.6; group.add(faceB);
  return group;
}

/* make multiple coins, staggered */
const coins = [];
const coinCount = 3;
for(let i=0;i<coinCount;i++){
  const g = makeCoin(i===0? 'AICM' : i===1? 'A' : '1');
  g.scale.set(1.8,1.8,1.8);
  g.position.set(420 + i*60, 0, 0); // start further right and offset for stagger
  scene.add(g);
  coins.push({group:g, delay:i*280});
}

/* animation control */
const START_X = 420;
const TARGET_X = -120;
const MOVE_DURATION = 2800; // ms per coin
let startT = null;

/* ease */
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

/* resize */
function onResize(){ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
window.addEventListener('resize', onResize);

/* optional debug controls (disabled) */
// const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enabled = false;

/* animation loop */
function render(ts){
  if(!startT) startT = ts;
  const elapsed = ts - startT;

  // animate each coin with its own delay
  coins.forEach((c,idx) => {
    const localT = Math.max(0, elapsed - c.delay);
    const p = Math.min(localT / MOVE_DURATION, 1);
    const eased = easeOutCubic(p);
    // x interpolation from START_X to TARGET_X with slight per coin offset
    const x = THREE.MathUtils.lerp(START_X + idx*30, TARGET_X + idx*18, eased);
    c.group.position.x = x;

    // rolling rotation: angle = traveledDistance / radius
    const traveled = (START_X + idx*30) - x;
    const angle = traveled / (coinRadius * 1.0);
    c.group.rotation.y = -angle;

    // bounce near end
    if(p > 0.82 && p < 1){
      const t2 = (p - 0.82) / 0.18;
      c.group.position.y = Math.sin(t2 * Math.PI * 2) * (1 - t2) * 7;
    } else if(p >= 1){
      c.group.position.y = 0;
      // idle small wobble
      c.group.rotation.x = Math.sin(ts * 0.0015 + idx) * 0.03;
    }
  });

  // camera subtle parallax toward left focal point for dynamic feel
  camera.position.x += (-60 - camera.position.x) * 0.02;
  camera.lookAt(0, 10, 0);

  renderer.render(scene, camera);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* click to replay */
window.addEventListener('click', () => {
  startT = null;
  coins.forEach((c, idx) => {
    c.group.position.set(START_X + idx*30, 0, 0);
    c.group.rotation.set(0,0,0);
  });
});
</script>
</body>
</html>
