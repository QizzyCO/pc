<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AICM-style 3D Coin (programmatic)</title>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<!-- Optional: OrbitControls (untuk debugging, disabled by default) -->
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<style>
  :root{
    --bg1: #f7f3ff;
    --bg2: #ebe8f6;
    --bg3: #e4e2f2;
  }
  html,body{
    margin:0;
    height:100%;
    background: linear-gradient(180deg,var(--bg1),var(--bg2) 40%, var(--bg3) 100%);
    font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
  }

  /* canvas akan mengisi viewport */
  #canvas {
    display:block;
    width:100vw;
    height:100vh;
  }

  /* overlay hero text on left */
  .hero {
    position: absolute;
    left: 6%;
    top: 50%;
    transform: translateY(-50%);
    color: #111;
    max-width: 540px;
    z-index: 5;
    pointer-events: none;
  }
  .hero h1{
    font-size: clamp(28px, 4.5vw, 56px);
    line-height: 1.05;
    margin:0;
    letter-spacing: -0.02em;
    font-weight:700;
  }
  .hero p{
    margin:12px 0 20px 0;
    opacity:0.75;
  }
  .hero .btn {
    display:inline-block;
    background:#0b0c33;
    color:white;
    padding:12px 28px;
    border-radius:40px;
    font-weight:600;
    pointer-events:auto;
    text-decoration:none;
  }

  /* subtle noise overlay like AICM */
  .noise {
    position:absolute;
    inset:0;
    background-image: url('https://i.ibb.co/2dYwMDr/noise.png');
    opacity:0.16;
    mix-blend-mode: overlay;
    z-index:4;
    pointer-events:none;
  }

  /* small gradient vignette at bottom-right to emulate glow */
  .vignette {
    position:absolute;
    right:6%;
    bottom:6%;
    width:480px;
    height:480px;
    border-radius:50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.85), rgba(255,255,255,0.08) 35%, transparent 60%);
    filter: blur(30px);
    z-index:2;
    pointer-events:none;
  }
</style>
</head>
<body>
  <div class="hero">
    <h1>The Smarter,<br> AI-Powered<br> Decentralized<br> Marketplace</h1>
    <p>Harness the power of decentralized AI marketplace with AICM.</p>
    <a class="btn" href="#">Search with AICM</a>
  </div>

  <canvas id="canvas"></canvas>
  <div class="noise"></div>
  <div class="vignette"></div>

<script>
/*
  Programmatic 3D coin + AICM-like background using Three.js
  - Coin is built from CylinderGeometry for rim + two circle faces with canvas textures
  - Animasi: translate X dari kanan ke posisi akhir, sambil rotasi (roll), micro-bounce di akhir.
  - Soft glass ring dibuat sebagai big torus-like mesh with transparent material (fake ring using TorusGeometry)
*/

const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;

// Scene & camera
const scene = new THREE.Scene();

// subtle fog for depth
scene.fog = new THREE.FogExp2(0xf4f2fb, 0.0006);

const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 5000);
camera.position.set(-120, 40, 220);

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0xaaaaaa, 0.6);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(100, 200, 100);
dir.castShadow = true;
dir.shadow.mapSize.set(1024,1024);
dir.shadow.camera.left = -300;
dir.shadow.camera.right = 300;
dir.shadow.camera.top = 300;
dir.shadow.camera.bottom = -300;
scene.add(dir);

// subtle fill point light
const fill = new THREE.PointLight(0xfff7e8, 0.6, 800);
fill.position.set(-200, 80, 150);
scene.add(fill);

// ground (invisible) to catch shadow - big plane
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(2000,2000),
  new THREE.ShadowMaterial({ opacity: 0.12 })
);
ground.rotation.x = -Math.PI/2;
ground.position.y = -60;
ground.receiveShadow = true;
scene.add(ground);

/* -------------------------
   Glass ring (fake) - use torus with wide tube + transparent material
   ------------------------- */
const ringGeo = new THREE.TorusGeometry(380, 88, 64, 120);
const ringMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0.0,
  roughness: 0.15,
  transmission: 0.9,
  thickness: 6,
  envMapIntensity: 0.6,
  opacity: 0.9,
  transparent: true,
  clearcoat: 0.8,
  clearcoatRoughness: 0.05
});
const glassRing = new THREE.Mesh(ringGeo, ringMat);
glassRing.position.set(180, 40, -30);
glassRing.rotation.set(THREE.MathUtils.degToRad(12), THREE.MathUtils.degToRad(-18), 0);
glassRing.receiveShadow = false;
glassRing.castShadow = false;
scene.add(glassRing);

/* subtle inner glow using sprite */
const glowTexture = new THREE.TextureLoader().load('https://i.ibb.co/9ntk7Xb/softcircle.png'); // small radial soft
const spriteMat = new THREE.SpriteMaterial({ map: glowTexture, color: 0xffffff, transparent:true, opacity:0.25 });
const sprite = new THREE.Sprite(spriteMat);
sprite.scale.set(600,600,1);
sprite.position.copy(glassRing.position).add(new THREE.Vector3(-40, -40, 0));
scene.add(sprite);

/* -------------------------
   Create coin textures via canvas
   ------------------------- */
function createCoinFaceTexture(text, size = 1024) {
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');

  // base gold radial
  const g = ctx.createRadialGradient(size*0.3, size*0.25, size*0.05, size/2, size/2, size/1.2);
  g.addColorStop(0, '#fff9e6');
  g.addColorStop(0.2, '#ffe77a');
  g.addColorStop(0.6, '#d99e1a');
  g.addColorStop(1, '#c48f10');

  ctx.fillStyle = g;
  ctx.fillRect(0,0,size,size);

  // subtle noise / scratches
  ctx.globalAlpha = 0.06;
  for(let i=0;i<4000;i++){
    ctx.fillStyle = i%2==0? 'rgba(255,255,255,0.02)' : 'rgba(0,0,0,0.02)';
    const x = Math.random()*size, y = Math.random()*size;
    const w = Math.random()*2;
    ctx.fillRect(x,y,w,0.5);
  }
  ctx.globalAlpha = 1;

  // inner ring
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = size*0.03;
  ctx.beginPath();
  ctx.arc(size/2,size/2,size*0.36,0,Math.PI*2);
  ctx.stroke();

  // text or emblem
  ctx.fillStyle = '#fff9e6';
  ctx.font = `${Math.floor(size*0.12)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, size/2, size/2);

  // return texture
  const tex = new THREE.CanvasTexture(c);
  tex.encoding = THREE.sRGBEncoding;
  tex.needsUpdate = true;
  return tex;
}

/* coin geometry */
const RIM_THICKNESS = 10;
const coinRadius = 40;
const coinThickness = 6;
const coinGroup = new THREE.Group();

// rim - cylinder (thin)
const rimGeo = new THREE.CylinderGeometry(coinRadius + RIM_THICKNESS, coinRadius + RIM_THICKNESS, coinThickness + 2, 64);
const rimMat = new THREE.MeshStandardMaterial({
  color: 0xbd8a10,
  metalness: 1.0,
  roughness: 0.25
});
const rim = new THREE.Mesh(rimGeo, rimMat);
rim.castShadow = true;
rim.receiveShadow = true;
rim.rotation.x = Math.PI/2;
coinGroup.add(rim);

// inner body (slightly smaller cylinder to create edge)
const bodyGeo = new THREE.CylinderGeometry(coinRadius, coinRadius, coinThickness, 64);
const bodyMat = new THREE.MeshPhysicalMaterial({
  color: 0xe3b335,
  metalness: 1.0,
  roughness: 0.18,
  clearcoat: 0.6,
  clearcoatRoughness: 0.05
});
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.rotation.x = Math.PI/2;
body.position.z = 0;
body.castShadow = true;
coinGroup.add(body);

// face meshes (use planes with textures slightly offset to avoid z-fighting)
const faceTexA = createCoinFaceTexture('AICM', 1024);
const faceTexB = createCoinFaceTexture('A', 1024);
const faceMat = new THREE.MeshStandardMaterial({
  map: faceTexA,
  metalness: 0.8,
  roughness:0.2,
});
const faceGeom = new THREE.CircleGeometry(coinRadius-2, 64);
const faceA = new THREE.Mesh(faceGeom, faceMat);
faceA.rotation.x = Math.PI/2;
faceA.position.z = coinThickness/2 + 0.5;
coinGroup.add(faceA);

// back face (flip texture or use different)
const faceMatB = new THREE.MeshStandardMaterial({
  map: faceTexB,
  metalness: 0.8,
  roughness:0.2,
});
const faceB = new THREE.Mesh(faceGeom, faceMatB);
faceB.rotation.x = -Math.PI/2;
faceB.position.z = -coinThickness/2 - 0.5;
coinGroup.add(faceB);

// position coin offscreen on the right (we'll translate it left)
coinGroup.position.set(400, 0, 0);
coinGroup.rotation.z = 0;
coinGroup.scale.set(1.8,1.8,1.8);
scene.add(coinGroup);

// shadow caster helper small
rim.castShadow = body.castShadow = faceA.castShadow = faceB.castShadow = true;

/* -------------------------
   Animation variables
   ------------------------- */
const TARGET_X = -120; // final x position
const START_X = 420;   // start x (offscreen right)
const DURATION = 3000; // ms total movement
let startTime = null;

/* ease function */
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

/* -------------------------
   Resize handling
   ------------------------- */
function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
window.addEventListener('resize', onWindowResize, false);

/* Optional: orbit controls for debugging (disabled for final) */
// const controls = new THREE.OrbitControls(camera, renderer.domElement);
// controls.enabled = false;

/* -------------------------
   Render loop
   ------------------------- */
function animate(ts){
  if(!startTime) startTime = ts;
  const elapsed = ts - startTime;

  // movement progress 0..1
  let p = Math.min(elapsed / DURATION, 1);
  let eased = easeOutCubic(p);

  // interpolate x
  const x = THREE.MathUtils.lerp(START_X, TARGET_X, eased);
  coinGroup.position.x = x;

  // rolling: when moving to left, rotate around Z axis appropriately.
  // The circumference is 2*pi*r; angle = distance / radius; use negative sign for roll direction.
  const traveled = START_X - x;
  const angle = traveled / (coinRadius * 1.0); // rad
  coinGroup.rotation.y = -angle; // rotate around Y so it looks like rolling

  // micro-bounce near end
  if(p > 0.85 && p < 1){
    const t2 = (p - 0.85) / 0.15; // 0..1
    const bounce = Math.sin(t2 * Math.PI * 2) * (1 - t2) * 6;
    coinGroup.position.y = bounce;
  } else if (p >= 1){
    // small idle wobble / subtle tilt
    coinGroup.position.y = 0;
    const wobble = Math.sin(ts * 0.002) * 1.2;
    coinGroup.rotation.x = wobble * 0.04;
  }

  // slight camera parallax for liveliness
  camera.position.x += ( -60 - camera.position.x ) * 0.02;
  camera.lookAt(0, 10, 0);

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* Good-to-have: responsive pixel ratio for perf on mobile */
if(window.devicePixelRatio > 1) {
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
}

/* Optional: click to replay animation */
window.addEventListener('click', () => {
  startTime = null;
  coinGroup.position.set(START_X,0,0);
  coinGroup.rotation.set(0,0,0);
});

</script>
</body>
</html>
